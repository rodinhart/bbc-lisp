\ http://localhost:8081/?disc1=lisp.ssd&autoboot

;; refactor print with eval?
;; macro for mov exp, ret etc?
;; macro for push exp etc?

oswrch = &FFEE
osasci = &FFE3
osnewl = &FFE7
ret = &70
exp = &72
env = &74
tmp = &76

ORG &2000

.start
    ; init free
    LDA free
    STA exp
    LDA free + 1
    STA exp + 1
    LDX #7
.init_free_loop
    LDY #0
    LDA #0
    STA (exp), Y
    LDY #1
    STA (exp), Y

    CLC

    LDA #32
    ADC free
    LDY #2
    STA (exp), Y
    STA free

    LDA #0
    ADC free + 1
    LDY #3
    STA (exp), Y
    STA free + 1

    LDA free
    STA exp
    LDA free + 1
    STA exp + 1

    DEX
    BNE init_free_loop

    LDA #0
    LDY #0
    STA (exp), Y
    LDY #1
    STA (exp), Y
    LDY #2
    STA (exp), Y
    LDY #3
    STA (exp), Y

    ; set free to first in chain
    LDA #end MOD 256
    STA free
    LDA #end DIV 256
    STA free + 1

    ; init stack
    LDX #255

    ; main
    LDA #code MOD 256
    STA exp
    LDA #code DIV 256
    STA exp + 1
    
    LDA #core MOD 256
    STA env
    LDA #core DIV 256
    STA env + 1
    JSR eval

    LDA ret
    STA exp
    LDA ret + 1
    STA exp + 1
    JSR print
    JSR osnewl

    RTS

.code
    EQUB 2, 'f', 'n', 0

.core
    EQUW core_x
    EQUW core + 4
    EQUW core_42
    EQUW 0
.core_x
    EQUB 2, 'f', 'n', 0
.core_42
    EQUB 6, &42, 0, 0

.eval
    JSR get_type
    TAY
    LDA eval_jumphigh, Y
    PHA
    LDA eval_jumplow, Y
    PHA
    RTS
.eval_jumplow
    EQUB (eval_nil - 1) MOD 256
    EQUB (eval_cons - 1) MOD 256
    EQUB (eval_nil - 1) MOD 256
    EQUB (eval_nil - 1) MOD 256
    EQUB (eval_nil - 1) MOD 256
    EQUB (eval_symbol - 1) MOD 256
    EQUB (eval_number - 1) MOD 256
.eval_jumphigh
    EQUB (eval_nil - 1) DIV 256
    EQUB (eval_cons - 1) DIV 256
    EQUB (eval_nil - 1) DIV 256
    EQUB (eval_nil - 1) DIV 256
    EQUB (eval_nil - 1) DIV 256
    EQUB (eval_symbol - 1) DIV 256
    EQUB (eval_number - 1) DIV 256

.eval_nil
.eval_number
    LDA exp
    STA ret
    LDA exp + 1
    STA ret + 1
    RTS

.eval_symbol
    LDY #0 ; tmp = car env
    LDA (env), Y
    STA tmp
    LDY #1
    LDA (env), Y
    STA tmp + 1

    LDY #1
    LDA (tmp), Y
    CMP (exp), Y
    BNE eval_symbol_next

    LDY #2 ; tmp = cdr env
    LDA (env), Y
    STA tmp
    LDY #3
    LDA (env), Y
    STA tmp + 1

    LDY #0 ; ret = car tmp
    LDA (tmp), Y
    STA ret
    LDY #1
    LDA (tmp), Y
    STA ret + 1
    RTS

.eval_symbol_next
    LDY #2 ; ret = cdr env
    LDA (env), Y
    STA ret
    LDY #3
    LDA (env), Y
    STA ret + 1

    LDY #2 ; env = cdr ret
    LDA (ret), Y
    STA env
    LDY #3
    LDA (ret), Y
    STA env + 1

    LDA #0
    CMP env
    BNE eval_symbol
    CMP env + 1
    BNE eval_symbol

    LDY #1
    LDA (exp), Y
    STA error_unknownsymbol
    LDY #2
    LDA (exp), Y
    STA error_unknownsymbol + 1
    LDY #3
    LDA (exp), Y
    STA error_unknownsymbol + 2
    BRK
    EQUB 0, "Unknown symbol "
.error_unknownsymbol
    EQUD 0
    EQUB 0

    LDA #0 ; return nil
    STA ret
    STA ret + 1
    RTS

.eval_cons
    LDA #0
    STA ret
    STA ret + 1
    RTS


.get_type ; exp => A
    ; nil?
    LDA #0
    CMP exp
    BNE get_type_notnil
    CMP exp + 1
    BNE get_type_notnil
    RTS ; return 0
.get_type_notnil
    LDY #0
    LDA (exp), Y
    BIT get_type_testcons
    BNE get_type_notcons
    LDY #2
    LDA (exp), Y
    AND get_type_consmask
    CLC
    ADC get_type_consbase
    RTS ; return 1 = Cons, 2 = Proc, 3 = Macro, 4 = Native
.get_type_notcons
    AND get_type_primmask
    LSR A
    LSR A
    CLC
    ADC get_type_primbase
    RTS ; return 5 = Symbol, 6 = Number
.get_type_testcons
    EQUB 2
.get_type_consmask
    EQUB 3
.get_type_consbase
    EQUB 1
.get_type_primmask
    EQUB 12
.get_type_primbase
    EQUB 5

.type_cons ; jump table?
    EQUB 0
.type_symbol
    EQUB 2
.type_number
    EQUB 6
.type_mask
    EQUB &E
.print
    JSR get_type
    TAY
    LDA print_jumphigh, Y
    PHA
    LDA print_jumplow, Y
    PHA
    RTS
.print_jumplow
    EQUB (print_nil - 1) MOD 256
    EQUB (print_cons - 1) MOD 256
    EQUB (print_nil - 1) MOD 256
    EQUB (print_nil - 1) MOD 256
    EQUB (print_nil - 1) MOD 256
    EQUB (print_symbol - 1) MOD 256
    EQUB (print_number - 1) MOD 256
.print_jumphigh
    EQUB (print_nil - 1) DIV 256
    EQUB (print_cons - 1) DIV 256
    EQUB (print_nil - 1) DIV 256
    EQUB (print_nil - 1) DIV 256
    EQUB (print_nil - 1) DIV 256
    EQUB (print_symbol - 1) DIV 256
    EQUB (print_number - 1) DIV 256

.print_nil
    LDA #'n'
    JSR osasci
    LDA #'i'
    JSR osasci
    LDA #'l'
    JSR osasci
    RTS

.print_cons
    LDA #'('
    JSR osasci
    LDA #0
    PHA
.print_loop
    PLA
    JSR osasci
    LDA #' '
    PHA

    DEX ; push exp
    LDA exp
    STA stack_low, X
    LDA exp + 1
    STA stack_high, X

    LDY #0 ; car
    LDA (exp), Y
    PHA
    LDY #1
    LDA (exp), Y
    STA exp + 1
    PLA
    STA exp
    JSR print

    LDA stack_low, X ; pull exp
    STA exp
    LDA stack_high, X
    STA exp + 1
    INX

    LDY #2 ; cdr
    LDA (exp), Y
    PHA
    LDY #3
    LDA (exp), Y
    STA exp + 1
    PLA
    STA exp

    ; nil?
    LDA #0
    CMP exp
    BNE print_loop
    CMP exp + 1
    BNE print_loop
.print_close
    PLA
    LDA #')'
    JSR osasci
    RTS

.print_symbol
    LDY #1
    LDA (exp), Y
    JSR osasci
    LDY #2
    LDA (exp), Y
    JSR osasci
    LDY #3
    LDA (exp), Y
    JSR osasci
    RTS

.print_number
    LDY #1
    LDA (exp), Y
    JSR print_byte
    RTS


.print_0
    EQUB '0'
    EQUB 15
.print_byte
    PHA
    LSR A
    LSR A
    LSR A
    LSR A
    CLC
    ADC print_0
    JSR osasci
    PLA
    AND print_0 + 1
    CLC
    ADC print_0
    JSR osasci
    RTS

.free_first
    LDA free
    STA ret
    LDA free + 1
    STA ret + 1

    LDY #0
    LDA (ret), Y
    STA free
    LDY #1
    LDA (ret), Y
    STA free + 1

    RTS
.free
    EQUB end MOD 256, end DIV 256

ALIGN &100
.stack_low
    SKIP 256
ALIGN &100
.stack_high
    SKIP 256
.end

SAVE "Lisp", start, end
