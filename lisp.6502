\ http://localhost:8081/?disc1=lisp.ssd&autoboot

;; macro for init cells?
;; macro nil?

oswrch = &FFEE
osasci = &FFE3
osnewl = &FFE7
ret = &70
exp = &72
env = &74
tmp = &76

MACRO ADDR target, address
    LDA #LO(address)
    STA target
    LDA #HI(address)
    STA target + 1
ENDMACRO

MACRO HEAD target, pair
    LDY #0
    LDA (pair), Y
    STA target
    INY
    LDA (pair), Y
    STA target + 1
ENDMACRO

MACRO MOVE target, source
    LDA source
    STA target
    LDA source + 1
    STA target + 1
ENDMACRO

MACRO PULL reg
    LDA stack_low, X
    STA exp
    LDA stack_high, X
    STA exp + 1
    INX
ENDMACRO

MACRO PUSH reg
    DEX
    LDA reg
    STA stack_low, X
    LDA reg + 1
    STA stack_high, X
ENDMACRO

MACRO TAIL target, pair
    LDY #2
    LDA (pair), Y
    STA target
    INY
    LDA (pair), Y
    STA target + 1
ENDMACRO

ORG &2000

.start
    ; init free
    MOVE exp, free
    LDX #7
.init_free_loop
    LDY #0
    LDA #0
    STA (exp), Y
    LDY #1
    STA (exp), Y

    CLC

    LDA #32
    ADC free
    LDY #2
    STA (exp), Y
    STA free

    LDA #0
    ADC free + 1
    LDY #3
    STA (exp), Y
    STA free + 1

    MOVE exp, free

    DEX
    BNE init_free_loop

    LDA #0
    LDY #0
    STA (exp), Y
    LDY #1
    STA (exp), Y
    LDY #2
    STA (exp), Y
    LDY #3
    STA (exp), Y

    ; set free to first in chain
    ADDR free, end

    ; init stack
    LDX #255

    ; main
    ADDR exp, code
    ADDR env, core
    JSR eval

    MOVE exp, ret
    JSR print
    JSR osnewl

    RTS

ALIGN 4
.code
    EQUB 2, '+', 0, 0

.core
    EQUW core_plus
    EQUW core + 4
    EQUW core_plus_
    EQUW 0
.core_plus
    EQUB 2, '+', 0, 0
.core_plus_
    EQUW native_plus
    EQUW 3

.native_plus ; ret = sum(exp)
    ADDR ret, hard
    RTS
ALIGN 4
.hard
    EQUB 6, &43, 0, 0

.eval
    JSR get_type
    TAY
    LDA eval_jumphigh, Y
    PHA
    LDA eval_jumplow, Y
    PHA
    RTS
.eval_jumplow
    EQUB LO(eval_nil - 1)
    EQUB LO(eval_cons - 1)
    EQUB LO(eval_nil - 1)
    EQUB LO(eval_nil - 1)
    EQUB LO(eval_nil - 1)
    EQUB LO(eval_symbol - 1)
    EQUB LO(eval_number - 1)
.eval_jumphigh
    EQUB HI(eval_nil - 1)
    EQUB HI(eval_cons - 1)
    EQUB HI(eval_nil - 1)
    EQUB HI(eval_nil - 1)
    EQUB HI(eval_nil - 1)
    EQUB HI(eval_symbol - 1)
    EQUB HI(eval_number - 1)

.eval_nil
.eval_number
    MOVE ret, exp
    RTS

.eval_symbol
    HEAD tmp, env

    LDY #1
    LDA (tmp), Y
    CMP (exp), Y
    BNE eval_symbol_next
    ;INY
    ;LDA (tmp), Y
    ;CMP (exp), Y
    ;BNE eval_symbol_next
    ;INY
    ;LDA (tmp), Y
    ;CMP (exp), Y
    ;BNE eval_symbol_next

    TAIL tmp, env
    HEAD ret, tmp
    RTS

.eval_symbol_next
    TAIL tmp, env
    TAIL env, tmp

    LDA #0
    CMP env
    BNE eval_symbol
    CMP env + 1
    BNE eval_symbol

    LDY #1
    LDA (exp), Y
    STA error_unknownsymbol
    LDY #2
    LDA (exp), Y
    STA error_unknownsymbol + 1
    LDY #3
    LDA (exp), Y
    STA error_unknownsymbol + 2
    BRK
    EQUB 0, "Unknown symbol "
.error_unknownsymbol
    EQUD 0
    EQUB 0

    LDA #0 ; return nil
    STA ret
    STA ret + 1
    RTS

.eval_cons
    LDA #0
    STA ret
    STA ret + 1
    RTS


.get_type ; exp => A
    ; nil?
    LDA #0
    CMP exp
    BNE get_type_notnil
    CMP exp + 1
    BNE get_type_notnil
    RTS ; return 0
.get_type_notnil
    LDY #0
    LDA (exp), Y
    BIT get_type_testcons
    BNE get_type_notcons
    LDY #2
    LDA (exp), Y
    AND get_type_mask
    CLC
    ADC get_type_consbase
    RTS ; return 1 = Cons, 2 = Proc, 3 = Macro, 4 = Native
.get_type_notcons
    LSR A
    LSR A
    AND get_type_mask
    CLC
    ADC get_type_primbase
    RTS ; return 5 = Symbol, 6 = Number
.get_type_testcons
    EQUB 2
.get_type_mask
    EQUB 3
.get_type_consbase
    EQUB 1
.get_type_primbase
    EQUB 5

.print
    JSR get_type
    TAY
    LDA print_jumphigh, Y
    PHA
    LDA print_jumplow, Y
    PHA
    RTS
.print_jumplow
    EQUB LO(print_nil - 1)
    EQUB LO(print_cons - 1)
    EQUB LO(print_nil - 1)
    EQUB LO(print_nil - 1)
    EQUB LO(print_native - 1)
    EQUB LO(print_symbol - 1)
    EQUB LO(print_number - 1)
.print_jumphigh
    EQUB HI(print_nil - 1)
    EQUB HI(print_cons - 1)
    EQUB HI(print_nil - 1)
    EQUB HI(print_nil - 1)
    EQUB HI(print_nil - 1)
    EQUB HI(print_symbol - 1)
    EQUB HI(print_number - 1)

.print_nil
    LDA #'n'
    JSR osasci
    LDA #'i'
    JSR osasci
    LDA #'l'
    JSR osasci
    RTS

.print_cons
    LDA #'('
    JSR osasci
    LDA #0
    PHA
.print_loop
    PLA
    JSR osasci
    LDA #' '
    PHA

    PUSH exp

    LDY #0 ; exp = car(exp)
    LDA (exp), Y
    PHA
    LDY #1
    LDA (exp), Y
    STA exp + 1
    PLA
    STA exp
    JSR print

    PULL exp

    LDY #2 ; exp = cdr(exp)
    LDA (exp), Y
    PHA
    LDY #3
    LDA (exp), Y
    STA exp + 1
    PLA
    STA exp

    ; nil?
    LDA #0
    CMP exp
    BNE print_loop
    CMP exp + 1
    BNE print_loop
.print_close
    PLA
    LDA #')'
    JSR osasci
    RTS

.print_native
    LDA #'['
    JSR osasci
    LDA #'N'
    JSR osasci
    LDA #'A'
    JSR osasci
    LDA #'T'
    JSR osasci
    LDA #']'
    JSR osasci
    RTS

.print_symbol
    LDY #1
    LDA (exp), Y
    JSR osasci
    LDY #2
    LDA (exp), Y
    JSR osasci
    LDY #3
    LDA (exp), Y
    JSR osasci
    RTS

.print_number
    LDY #1
    LDA (exp), Y
    JSR print_byte
    RTS


.print_0
    EQUB '0'
    EQUB 15
.print_byte
    PHA
    LSR A
    LSR A
    LSR A
    LSR A
    CLC
    ADC print_0
    JSR osasci
    PLA
    AND print_0 + 1
    CLC
    ADC print_0
    JSR osasci
    RTS

.free_first
    LDA free
    STA ret
    LDA free + 1
    STA ret + 1

    LDY #0
    LDA (ret), Y
    STA free
    LDY #1
    LDA (ret), Y
    STA free + 1

    RTS
.free
    EQUB end MOD 256, end DIV 256

ALIGN &100
.stack_low
    SKIP 256
ALIGN &100
.stack_high
    SKIP 256
.end

SAVE "Lisp", start, end
