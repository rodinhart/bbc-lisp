\ http://localhost:8081/?disc1=lisp.ssd&autoboot

;; compare full symbol for eval symbol
;; read decimal
;; print string
;; make all label verbNoun_sublabel
;; macro for init cells?
;; macro nil?
;; native doesn't have to be cell aligned
;; ZERO exp ?

oswrch = &FFEE
osasci = &FFE3
osnewl = &FFE7
ret = &70
exp = &72
env = &74
tmp = &76

MACRO ADDR reg, address
    LDA #LO(address)
    STA reg
    LDA #HI(address)
    STA reg + 1
ENDMACRO

MACRO HEAD reg, pair
IF reg != pair
    LDY #0
    LDA (pair), Y
    STA reg
    INY
    LDA (pair), Y
    STA reg + 1
ELSE
    LDY #0
    LDA (pair), Y
    PHA
    INY
    LDA (pair), Y
    STA reg + 1
    PLA
    STA reg
ENDIF
ENDMACRO

MACRO HEADSET pair, reg
    LDA reg
    LDY #0
    STA (pair), Y
    LDA reg + 1
    INY
    STA (pair), Y
ENDMACRO

MACRO MOVE target, source
    LDA source
    STA target
    LDA source + 1
    STA target + 1
ENDMACRO

MACRO PULL reg
    DEX
    LDA stack_low, X
    STA reg
    LDA stack_high, X
    STA reg + 1
ENDMACRO

MACRO PUSH reg
    LDA reg
    STA stack_low, X
    LDA reg + 1
    STA stack_high, X
    INX
ENDMACRO

MACRO TAIL reg, pair
IF reg != pair
    LDY #2
    LDA (pair), Y
    STA reg
    INY
    LDA (pair), Y
    STA reg + 1
ELSE
    LDY #2
    LDA (pair), Y
    PHA
    INY
    LDA (pair), Y
    STA reg + 1
    PLA
    STA reg
ENDIF
ENDMACRO

MACRO TAILSET pair, reg
    LDA reg
    LDY #2
    STA (pair), Y
    LDA reg + 1
    INY
    STA (pair), Y
ENDMACRO

ORG &2000

.start
    JSR freeInit
    LDX #0 ; init stack
    JSR freeReport

    ADDR exp, source
    JSR read

    PUSH ret
    MOVE exp, ret
    JSR print
    JSR osnewl

    PULL exp
    ADDR env, core
    JSR eval
    
    MOVE exp, ret
    JSR print
    JSR osnewl

    RTS

.source
    EQUB "(fn (x) (+ x x))", 0

ALIGN 4
.core
    EQUW core_plus
    EQUW core + 4
    EQUW core_plus_
    EQUW core + 8
    EQUW coreNil
    EQUW core + 12
    EQUW 0
    EQUW 0
.core_plus
    EQUB 2, '+', 0, 0
.core_plus_
    EQUW native_plus
    EQUW 3
.coreNil
    EQUB 2, "nil"

.native_plus ; (fn args (reduce + 0 args))
    LDA #0
    PHA
.native_plus_loop
    LDA #0
    CMP exp
    BNE native_plus_add
    CMP exp + 1 
    BEQ native_plus_done
.native_plus_add
    HEAD tmp, exp
    PLA
    LDY #1 
    CLC
    ADC (tmp), Y
    PHA
    TAIL exp, exp
    JMP native_plus_loop
.native_plus_done
    JSR freeAlloc
    LDA #6
    LDY #0
    STA (ret), Y
    PLA
    LDY #1
    STA (ret), Y
    RTS

.native_len_count
    EQUB 0
.native_len ; A = len(exp)
    LDA #0
    STA native_len_count
.native_len_loop
    LDA #0
    CMP exp
    BNE native_len_next
    CMP exp + 1
    BNE native_len_next
    LDA native_len_count
    RTS
.native_len_next
    INC native_len_count
    TAIL exp, exp
    JMP native_len_loop

.eval
    JSR getType
    LDA eval_jumphigh, Y
    PHA
    LDA eval_jumplow, Y
    PHA
    RTS
.eval_jumplow
    EQUB LO(eval_nil - 1)
    EQUB LO(eval_cons - 1)
    EQUB LO(eval_nil - 1)
    EQUB LO(eval_nil - 1)
    EQUB LO(eval_nil - 1)
    EQUB LO(eval_symbol - 1)
    EQUB LO(eval_number - 1)
.eval_jumphigh
    EQUB HI(eval_nil - 1)
    EQUB HI(eval_cons - 1)
    EQUB HI(eval_nil - 1)
    EQUB HI(eval_nil - 1)
    EQUB HI(eval_nil - 1)
    EQUB HI(eval_symbol - 1)
    EQUB HI(eval_number - 1)

.eval_nil
.eval_number
    MOVE ret, exp
    RTS

.eval_symbol
    HEAD tmp, env

    LDY #1
    LDA (tmp), Y
    CMP (exp), Y
    BNE eval_symbol_next

    TAIL tmp, env
    HEAD ret, tmp
    RTS

.eval_symbol_next
    TAIL tmp, env
    TAIL env, tmp

    LDA #0
    CMP env
    BNE eval_symbol
    CMP env + 1
    BNE eval_symbol

    LDY #1
    LDA (exp), Y
    STA error_unknownsymbol
    LDY #2
    LDA (exp), Y
    STA error_unknownsymbol + 1
    LDY #3
    LDA (exp), Y
    STA error_unknownsymbol + 2
    BRK
    EQUB 0, "Unknown symbol "
.error_unknownsymbol
    EQUD 0
    EQUB 0

    LDA #0 ; return nil
    STA ret
    STA ret + 1
    RTS

.eval_cons
    JSR evalMap ; (+ 2 3 5)
    HEAD exp, ret
    HEAD tmp, exp
    TAIL exp, ret
    JMP (tmp)

.evalMap ; (fn (exp) (if (nil? exp) nil (cons (eval (car exp)) (evalMap (cdr exp)))))
    LDA #0
    CMP exp
    BNE evalMap_map
    CMP exp + 1
    BNE evalMap_map
    STA ret
    STA ret + 1
    RTS
.evalMap_map
    PUSH exp
    PUSH env
    HEAD exp, exp
    JSR eval
    PULL env
    PULL tmp
    PUSH ret
    TAIL exp, tmp
    JSR evalMap
    PUSH ret
    JSR freeAlloc
    PULL tmp
    TAILSET ret, tmp
    PULL tmp
    HEADSET ret, tmp
    RTS

.getType ; exp => Y
    ; nil?
    LDY #0
    CPY exp
    BNE getType_notnil
    CPY exp + 1
    BNE getType_notnil
    RTS ; return 0
.getType_notnil
    LDA (exp), Y
    BIT getType_testcons
    BNE getType_notcons
    LDY #2
    LDA (exp), Y
    AND getType_mask
    CLC
    ADC getType_consbase
    TAY
    RTS ; return 1 = Cons, 2 = Proc, 3 = Macro, 4 = Native
.getType_notcons
    LSR A
    LSR A
    AND getType_mask
    CLC
    ADC getType_primbase
    TAY
    RTS ; return 5 = Symbol, 6 = Number
.getType_testcons
    EQUB 2
.getType_mask
    EQUB 3
.getType_consbase
    EQUB 1
.getType_primbase
    EQUB 5

.print
    JSR getType
    LDA print_jumphigh, Y
    PHA
    LDA print_jumplow, Y
    PHA
    RTS
.print_jumplow
    EQUB LO(print_nil - 1)
    EQUB LO(print_cons - 1)
    EQUB LO(print_nil - 1)
    EQUB LO(print_nil - 1)
    EQUB LO(print_native - 1)
    EQUB LO(print_symbol - 1)
    EQUB LO(print_number - 1)
.print_jumphigh
    EQUB HI(print_nil - 1)
    EQUB HI(print_cons - 1)
    EQUB HI(print_nil - 1)
    EQUB HI(print_nil - 1)
    EQUB HI(print_native - 1)
    EQUB HI(print_symbol - 1)
    EQUB HI(print_number - 1)

.print_nil
    LDA #'n'
    JSR osasci
    LDA #'i'
    JSR osasci
    LDA #'l'
    JSR osasci
    RTS

.print_cons
    LDA #'('
    JSR osasci
    LDA #0
    PHA
.print_loop
    PLA
    JSR osasci
    LDA #' '
    PHA

    PUSH exp

    HEAD exp, exp
    JSR print

    PULL tmp
    TAIL exp, tmp

    ; nil?
    LDA #0
    CMP exp
    BNE print_loop
    CMP exp + 1
    BNE print_loop
.print_close
    PLA
    LDA #')'
    JSR osasci
    RTS

.print_native
    LDA #'['
    JSR osasci
    LDA #'N'
    JSR osasci
    LDA #'A'
    JSR osasci
    LDA #'T'
    JSR osasci
    LDA #']'
    JSR osasci
    RTS

.print_symbol
    LDY #1
    LDA (exp), Y
    JSR osasci
    INY
    LDA (exp), Y
    JSR osasci
    INY
    LDA (exp), Y
    JSR osasci
    RTS

.print_number
    LDY #1
    LDA (exp), Y
    JSR printDecimal
    RTS


.print_0
    EQUB '0'
    EQUB 15
.printByte
    PHA
    LSR A
    LSR A
    LSR A
    LSR A
    CMP #10
    BCC printByte_dec
    CLC
    ADC #6 ; use lookup?
.printByte_dec
    ADC print_0
    JSR osasci
    PLA
    AND print_0 + 1
    CMP #10
    BCC printByte_second
    CLC
    ADC #6
.printByte_second
    CLC
    ADC print_0
    JSR osasci
    RTS

.printDecimal_buffer
    EQUS "   "
.printDecimal ; print A
    LDY #0
    STY printDecimal_buffer
    STY printDecimal_buffer + 1
    STY printDecimal_buffer + 2
.printDecimal_loop
    CMP #10
    BCC printDecimal_next
    SBC #10
    INY
    JMP printDecimal_loop
.printDecimal_next
    PHA
    LDA printDecimal_buffer + 1
    STA printDecimal_buffer + 2
    LDA printDecimal_buffer
    STA printDecimal_buffer + 1
    PLA
    CLC
    ADC print_0
    STA printDecimal_buffer
    TYA
    LDY #0

    CMP #0
    BNE printDecimal_loop
.printDecimal_print
    LDA printDecimal_buffer
    JSR osasci
    LDA printDecimal_buffer + 1
    JSR osasci
    LDA printDecimal_buffer + 2
    JSR osasci
    RTS

.free
    EQUB LO(end), HI(end)
.freeHeapSize
    EQUB 128

.freeAlloc
    LDA #0
    CMP free
    BNE freeAlloc_notnil
    CMP free + 1
    BEQ free_outofmemory
.freeAlloc_notnil
    MOVE ret, free
    TAIL free, ret
    LDA #0
    LDY #0
    STA (ret), Y
    INY
    STA (ret), Y
    INY
    STA (ret), Y
    INY
    STA (ret), Y
    RTS
.free_outofmemory
    BRK
    EQUB 0, "Out of memory", 0

.freeCollect
    TXA
    PHA
    LDA #0
    STA free
    STA free + 1
    ADDR tmp, end
    LDX freeHeapSize
.freeCollect_loop
    LDY #0
    LDA (tmp), Y
    BIT freeMark_mask
    BNE freeCollect_skip

    TAILSET tmp, free
    MOVE free, tmp
.freeCollect_next
    LDA #32
    CLC
    ADC tmp
    STA tmp
    LDA #0
    ADC tmp + 1
    STA tmp + 1
    DEX
    BNE freeCollect_loop
    PLA
    TAX
    RTS
.freeCollect_skip
    AND #&FE ; clear mark
    STA (tmp), Y
    JMP freeCollect_next

.freeGC_sp
    EQUB 0
.freeGC
    STX freeGC_sp
.freeGC_loop
    LDY freeGC_sp
    BEQ freeGC_end
    DEY
    STY freeGC_sp
    LDA stack_low, Y
    STA exp
    LDA stack_high, Y
    STA exp + 1
    JSR freeMark
    JMP freeGC_loop
.freeGC_end
    JMP freeCollect


.freeInit
    ADDR tmp, end
    LDY #0
    LDX freeHeapSize
.freeInit_loop
    LDA #0 ; clear marked
    STA (tmp), Y
    LDA #32
    CLC
    ADC tmp
    STA tmp
    LDA #0
    ADC tmp + 1
    STA tmp + 1
    DEX
    BNE freeInit_loop

    JSR freeCollect
    RTS

.freeMark_mask
    EQUB 1
.freeMark
    LDA #0
    CMP exp
    BNE freeMark_notnil
    CMP exp + 1
    BNE freeMark_notnil
    RTS
.freeMark_notnil
    LDY #0
    LDA (exp), Y
    BIT freeMark_mask
    BNE freeMark_done

    JSR getType
    LDA freeMark_jumphigh, Y
    PHA
    LDA freeMark_jumplow, Y
    PHA
.freeMark_done
    RTS
.freeMark_jumplow ; perhaps jump table is overkill here
    EQUB LO(freeMark_done - 1)
    EQUB LO(freeMark_cons - 1)
    EQUB LO(freeMark_mark - 1)
    EQUB LO(freeMark_mark - 1)
    EQUB LO(freeMark_mark - 1)
    EQUB LO(freeMark_mark - 1)
    EQUB LO(freeMark_mark - 1)
.freeMark_jumphigh
    EQUB HI(freeMark_done - 1)
    EQUB HI(freeMark_cons - 1)
    EQUB HI(freeMark_mark - 1)
    EQUB HI(freeMark_mark - 1)
    EQUB HI(freeMark_mark - 1)
    EQUB HI(freeMark_mark - 1)
    EQUB HI(freeMark_mark - 1)

.freeMark_mark
    LDY #0
    LDA #1
    ORA (exp), Y
    STA (exp), Y
    RTS

.freeMark_cons
    PUSH exp
    HEAD tmp, exp
    LDY #0
    LDA #1
    ORA (exp), Y
    STA (exp), Y
    MOVE exp, tmp
    JSR freeMark
    PULL tmp
    TAIL exp, tmp
    JMP freeMark


.freeReport
    LDA #'F'
    JSR osasci
    LDA #'r'
    JSR osasci
    LDA #'e'
    JSR osasci
    LDA #'e'
    JSR osasci
    LDA #' '
    JSR osasci
    MOVE exp, free
    JSR native_len
    JSR printDecimal

    LDA #',' ; print stack
    JSR osasci
    LDA #' '
    JSR osasci
    TXA
    JSR printDecimal

    JSR osnewl
    RTS

.readList_proxy
    JMP readList
.read_cursor
    EQUB 0
.read
    LDY #0
    STY read_cursor
.readToken
    JSR readWS
    LDY read_cursor
    LDA (exp), Y
    CMP #'('
    BEQ readList_proxy
    CMP #'0'
    BCC readToken_notnumber
    CMP #':'
    BCS readToken_notnumber

    LDA #0 ; clear buffer
    STA readNumber_buffer
    STA readNumber_buffer + 1
    STA readNumber_buffer + 2
.readNumber_loop
    LDA readNumber_buffer
    ASL A
    ASL A
    ASL A
    ASL A
    STA readNumber_buffer
    LDY read_cursor
    LDA (exp), Y
    SEC
    SBC print_0
    ORA readNumber_buffer
    STA readNumber_buffer

    INC read_cursor
    LDY read_cursor
    LDA (exp), Y
    CMP #'0'
    BCC readNumber_end
    CMP #':'
    BCC readNumber_loop
.readNumber_end
    JSR freeAlloc
    LDA #6 ; refactor create_number
    LDY #0
    STA (ret), Y
    LDA readNumber_buffer
    INY
    STA (ret), Y
    LDA readNumber_buffer + 1
    INY
    STA (ret), Y
    LDA readNumber_buffer + 2
    INY
    STA (ret), Y
    RTS

.readNumber_buffer
    EQUB 0, 0, 0

.readToken_notnumber
    JSR freeAlloc
    LDA #2
    LDY #0
    STA (ret), Y

    ; read first char
    LDY read_cursor
    LDA (exp), Y
    LDY #1
    STA (ret), Y
    INC read_cursor

    ; read second char
    LDY read_cursor 
    LDA (exp), Y
    CMP #33
    BCC readSymbol_end
    CMP #')'
    BEQ readSymbol_end
    LDY #2
    STA (ret), Y
    INC read_cursor

    ; read third char
    LDY read_cursor 
    LDA (exp), Y
    CMP #33
    BCC readSymbol_end
    CMP #')'
    BEQ readSymbol_end
    LDY #3
    STA (ret), Y
    INC read_cursor

.readSymbol_end
    RTS

.readWS
    LDY read_cursor
    LDA (exp), Y
    CMP #33
    BCS readWS_end
    INC read_cursor
    BCC readWS
.readWS_end
    CMP #0
    BEQ readWS_endoffile
    RTS
.readWS_endoffile
    BRK
    EQUB 0, "Unexpected end of file", 0

.readList
    INC read_cursor ; skip '('
    JSR freeAlloc
    PUSH ret
.readList_loop
    JSR readWS
    LDY read_cursor
    LDA (exp), Y
    CMP #')'
    BEQ readList_end

    PUSH ret
    JSR readToken
    MOVE tmp, ret
    JSR freeAlloc
    HEADSET ret, tmp
    MOVE tmp, ret
    PULL ret
    TAILSET ret, tmp
    MOVE ret, tmp
    JMP readList_loop
.readList_end
    INC read_cursor ; skip ')'
    PULL tmp
    LDY #2
    LDA (tmp), Y
    STA ret
    LDY #3
    LDA (tmp), Y
    STA ret + 1
    RTS

ALIGN &100
.stack_low
    SKIP 256
ALIGN &100
.stack_high
    SKIP 256
.end

SAVE "Lisp", start, end
